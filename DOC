Coding consideration
====================

You need a C++11 compiler.


Write an application
====================

Use the Pipeline namespace.

ORDER OF ALLOC


Write a module
==============

Use the Modules namespace.

Constructor: use hard types.
flush() = EOS

* Inputs

In the pipeline, input modules will be called two times on void ::process(Data data): onece at the beginning, and one when asked to exit on each input pin. Therefore the structure should be:
```
void module::process(Data data) {
	while (getInput(0)->tryPop(data)) {
		auto out = outputs[0]->getBuffer(0);
		[do my stuff here]
		out->setTime(time);
		output->emit(out);
	}
}
```
TODO: add a test framework for modules (to prove they behave as expected by the API).

If your last input pin has the type DataLoose, you should ignore it. It means it is a fake input pin for:
 - Dynamic input pins (e.g. muxers).
 - Sources which need to receive input null data.

TODO

* Allocator
MAKE A LIST OF BASIC OBJECTS
* Data: shared_ptr
* Output
...


Framework architecture
======================

Signals is layered (from bottom to top):
- signals: a signal-slot system
- modules: a generic set of module interfaces and connection helpers
- mm? TODO multimedia consideration (modules would be agnostic)
- media: some module implementations based on libmodules
- pipeline: pipeline builder and connection helpers


Technical considerations
========================

* Parallelism

With Pipeline, automatic over a thread pool with an ID preventing parallel execution on the same module.

only use a thread if you need the system clock
a clock can be injected in modules

* Data types

* metadata
